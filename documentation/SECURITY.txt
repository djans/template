To configure **authorization** in a **Spring Boot** application, you would typically use **Spring Security** to manage authentication and authorization (including role-based access control). This is usually done through **Java configuration** (via annotations or Java classes), rather than the traditional `web.xml` file as in older servlet-based applications.

### Steps to Secure a Spring Boot Application Using Role-Based Authorization

1. **Add Spring Security Dependency**:
   If you haven't added **Spring Security** to your Spring Boot application, you need to include the relevant dependency in your `pom.xml` or `build.gradle` file.

#### **For Maven (`pom.xml`)**:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

#### **For Gradle (`build.gradle`)**:

```gradle
implementation 'org.springframework.boot:spring-boot-starter-security'
```

### 2. **Configure Spring Security for Role-Based Access Control**

You will need to create a class that configures **Spring Security**. This is usually done in a `@Configuration` class using **Java Config**.

#### Example Security Configuration with Role-Based Authorization:

```java
package com.example.demo.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.InMemoryUserDetailsManager;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/admin/**").hasRole("ADMIN")  // Only accessible by users with ADMIN role
                .antMatchers("/user/**").hasAnyRole("USER", "ADMIN")  // Accessible by users with USER or ADMIN roles
                .anyRequest().authenticated()  // All other requests require authentication
            .and()
            .formLogin()  // Enables form-based authentication
            .permitAll()
            .and()
            .httpBasic();  // Allows HTTP Basic Authentication (for testing purposes)
    }

    // In-memory user details (for demonstration purposes)
    @Override
    @Bean
    public UserDetailsService userDetailsService() {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();

        manager.createUser(User.withUsername("admin").password("{noop}adminpass").roles("ADMIN").build());
        manager.createUser(User.withUsername("user").password("{noop}userpass").roles("USER").build());

        return manager;
    }
}
```

### Key Points of the Configuration:

1. **`@EnableWebSecurity`**: This annotation enables **Spring Security** for your Spring Boot application.

2. **Role-Based Authorization (`antMatchers`)**:

   * `/admin/**` is only accessible by users with the `ADMIN` role.
   * `/user/**` is accessible by users with either `USER` or `ADMIN` roles.
   * `anyRequest().authenticated()` means that any other request must be authenticated (but not necessarily authorized for specific roles).

3. **`formLogin()`**: Enables form-based login for authentication.

4. **`httpBasic()`**: Adds basic HTTP authentication support (useful for testing).

5. **In-Memory Authentication**: In this example, we use an **in-memory user details manager** with two users:

   * **admin** with password `adminpass` and `ADMIN` role.
   * **user** with password `userpass` and `USER` role.

   The `{noop}` in the password is a Spring Security password encoder, indicating "no encoding" (plain text).

### 3. **Securing Specific Controllers Based on Roles**

In addition to securing URLs globally, you can also secure specific controller methods using annotations such as `@PreAuthorize` or `@Secured`.

#### Using `@PreAuthorize` (Method-Level Authorization)

You can restrict method access based on roles using the `@PreAuthorize` annotation.

```java
package com.example.demo.controller;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyController {

    @GetMapping("/admin/dashboard")
    @PreAuthorize("hasRole('ADMIN')")  // Only accessible by users with the ADMIN role
    public String adminDashboard() {
        return "Welcome to the Admin Dashboard!";
    }

    @GetMapping("/user/dashboard")
    @PreAuthorize("hasAnyRole('USER', 'ADMIN')")  // Accessible by both USER and ADMIN roles
    public String userDashboard() {
        return "Welcome to the User Dashboard!";
    }
}
```

* The `@PreAuthorize` annotation checks the user's roles before allowing access to the method.
* **`hasRole('ADMIN')`**: This ensures that only users with the `ADMIN` role can access this method.
* **`hasAnyRole('USER', 'ADMIN')`**: Allows access to users with either `USER` or `ADMIN` roles.

#### Using `@Secured` (Alternative Method-Level Authorization)

Alternatively, you can use the `@Secured` annotation for method-level authorization.

```java
package com.example.demo.controller;

import org.springframework.security.access.annotation.Secured;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyController {

    @GetMapping("/admin/dashboard")
    @Secured("ROLE_ADMIN")  // Only accessible by users with the ROLE_ADMIN role
    public String adminDashboard() {
        return "Welcome to the Admin Dashboard!";
    }

    @GetMapping("/user/dashboard")
    @Secured({"ROLE_USER", "ROLE_ADMIN"})  // Accessible by users with ROLE_USER or ROLE_ADMIN roles
    public String userDashboard() {
        return "Welcome to the User Dashboard!";
    }
}
```

* **`@Secured("ROLE_ADMIN")`**: Restricts access to only users with the `ADMIN` role.
* **`@Secured({"ROLE_USER", "ROLE_ADMIN"})`**: Allows access to both `USER` and `ADMIN` roles.

Note: You need to enable **pre/post annotations** for `@PreAuthorize` and `@Secured` to work:

```java
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
}
```

### 4. **Customizing Authentication (JWT or Database)**

In real-world applications, you would likely use a **JWT (JSON Web Token)** or a **database-backed** authentication system instead of in-memory authentication.

* **JWT Authentication**: You can use a custom filter to validate JWT tokens and set up Spring Security to authenticate based on JWT tokens.
* **Database Authentication**: You would configure Spring Security to use `JdbcUserDetailsManager` or a custom `UserDetailsService` to authenticate users from a database.

### Example of Configuring JWT Authentication

```java
package com.example.demo.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeRequests()
                .antMatchers("/admin/**").hasRole("ADMIN")
                .antMatchers("/user/**").hasAnyRole("USER", "ADMIN")
                .anyRequest().authenticated()
            .and()
            .addFilter(new JWTAuthenticationFilter(authenticationManager()))
            .addFilter(new JWTAuthorizationFilter(authenticationManager()));
    }

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
}
```

Here, **JWTAuthenticationFilter** would handle JWT authentication, and **JWTAuthorizationFilter** would handle authorization by checking the JWT token.

### 5. **Testing Authorization**

1. **Run the Application**: Run your Spring Boot application.
2. **Access Protected Resources**: Try to access URLs like `/admin/*` or `/user/*` with different roles. If you are logged in with the correct roles, you should be granted access. Otherwise, you will be redirected to a login page (or receive an access denied error).

#### Testing with Basic Authentication:

* You can use tools like **Postman** or **cURL** to test the authentication. For example:

```bash
curl -u user:userpass http://localhost:8080/user/dashboard
```

---

### Summary:

1. **Spring Security** in Spring Boot is used for authentication and role-based authorization.
2. Use **Java configuration** (`@Configuration`) to configure security settings, rather than using `web.xml`.
3. Use **`@PreAuthorize`** or **`@Secured`** for method-level authorization.
4. **JWT** or **database-backed authentication** can be integrated for real-world applications.
5. Spring Boot provides **in-memory authentication** out of the box, which you can replace with your custom user details service as needed.

Let me know if you need further clarification or additional examples!
